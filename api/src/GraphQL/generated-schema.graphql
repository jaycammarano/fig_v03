# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateArtist {
  _avg: ArtistAvgAggregate
  _count: ArtistCountAggregate
  _max: ArtistMaxAggregate
  _min: ArtistMinAggregate
  _sum: ArtistSumAggregate
}

type AggregateArtistsOnReleases {
  _avg: ArtistsOnReleasesAvgAggregate
  _count: ArtistsOnReleasesCountAggregate
  _max: ArtistsOnReleasesMaxAggregate
  _min: ArtistsOnReleasesMinAggregate
  _sum: ArtistsOnReleasesSumAggregate
}

type AggregateRelease {
  _avg: ReleaseAvgAggregate
  _count: ReleaseCountAggregate
  _max: ReleaseMaxAggregate
  _min: ReleaseMinAggregate
  _sum: ReleaseSumAggregate
}

type Artist {
  artistsOnReleases(cursor: ArtistsOnReleasesWhereUniqueInput, distinct: [ArtistsOnReleasesScalarFieldEnum!], orderBy: [ArtistsOnReleasesOrderByInput!], skip: Int, take: Int, where: ArtistsOnReleasesWhereInput): [ArtistsOnReleases!]!
  createdAt: DateTime!
  id: Int!
  image: String!
  name: String!
  releases(cursor: ReleaseWhereUniqueInput, distinct: [ReleaseScalarFieldEnum!], orderBy: [ReleaseOrderByInput!], skip: Int, take: Int, where: ReleaseWhereInput): [Release!]!
}

type ArtistAvgAggregate {
  id: Float
}

type ArtistCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  image: Int!
  name: Int!
}

input ArtistCreateInput {
  artistsOnReleases: ArtistsOnReleasesCreateNestedManyWithoutArtistInput
  createdAt: DateTime
  image: String
  name: String!
  releases: ReleaseCreateNestedManyWithoutArtistsInput
}

input ArtistCreateManyInput {
  createdAt: DateTime
  id: Int
  image: String
  name: String!
}

input ArtistCreateNestedManyWithoutReleasesInput {
  connect: [ArtistWhereUniqueInput!]
  connectOrCreate: [ArtistCreateOrConnectWithoutReleasesInput!]
  create: [ArtistCreateWithoutReleasesInput!]
}

input ArtistCreateNestedOneWithoutArtistsOnReleasesInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutArtistsOnReleasesInput
  create: ArtistCreateWithoutArtistsOnReleasesInput
}

input ArtistCreateOrConnectWithoutArtistsOnReleasesInput {
  create: ArtistCreateWithoutArtistsOnReleasesInput!
  where: ArtistWhereUniqueInput!
}

input ArtistCreateOrConnectWithoutReleasesInput {
  create: ArtistCreateWithoutReleasesInput!
  where: ArtistWhereUniqueInput!
}

input ArtistCreateWithoutArtistsOnReleasesInput {
  createdAt: DateTime
  image: String
  name: String!
  releases: ReleaseCreateNestedManyWithoutArtistsInput
}

input ArtistCreateWithoutReleasesInput {
  artistsOnReleases: ArtistsOnReleasesCreateNestedManyWithoutArtistInput
  createdAt: DateTime
  image: String
  name: String!
}

type ArtistGroupBy {
  _avg: ArtistAvgAggregate
  _count: ArtistCountAggregate
  _max: ArtistMaxAggregate
  _min: ArtistMinAggregate
  _sum: ArtistSumAggregate
  createdAt: DateTime!
  id: Int!
  image: String!
  name: String!
}

input ArtistListRelationFilter {
  every: ArtistWhereInput
  none: ArtistWhereInput
  some: ArtistWhereInput
}

type ArtistMaxAggregate {
  createdAt: DateTime
  id: Int
  image: String
  name: String
}

type ArtistMinAggregate {
  createdAt: DateTime
  id: Int
  image: String
  name: String
}

input ArtistOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
}

input ArtistRelationFilter {
  is: ArtistWhereInput
  isNot: ArtistWhereInput
}

enum ArtistScalarFieldEnum {
  createdAt
  id
  image
  name
}

input ArtistScalarWhereInput {
  AND: [ArtistScalarWhereInput!]
  NOT: [ArtistScalarWhereInput!]
  OR: [ArtistScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  image: StringFilter
  name: StringFilter
}

input ArtistScalarWhereWithAggregatesInput {
  AND: [ArtistScalarWhereWithAggregatesInput!]
  NOT: [ArtistScalarWhereWithAggregatesInput!]
  OR: [ArtistScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  image: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type ArtistSumAggregate {
  id: Int
}

input ArtistUpdateInput {
  artistsOnReleases: ArtistsOnReleasesUpdateManyWithoutArtistInput
  createdAt: DateTimeFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  releases: ReleaseUpdateManyWithoutArtistsInput
}

input ArtistUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ArtistUpdateManyWithWhereWithoutReleasesInput {
  data: ArtistUpdateManyMutationInput!
  where: ArtistScalarWhereInput!
}

input ArtistUpdateManyWithoutReleasesInput {
  connect: [ArtistWhereUniqueInput!]
  connectOrCreate: [ArtistCreateOrConnectWithoutReleasesInput!]
  create: [ArtistCreateWithoutReleasesInput!]
  delete: [ArtistWhereUniqueInput!]
  deleteMany: [ArtistScalarWhereInput!]
  disconnect: [ArtistWhereUniqueInput!]
  set: [ArtistWhereUniqueInput!]
  update: [ArtistUpdateWithWhereUniqueWithoutReleasesInput!]
  updateMany: [ArtistUpdateManyWithWhereWithoutReleasesInput!]
  upsert: [ArtistUpsertWithWhereUniqueWithoutReleasesInput!]
}

input ArtistUpdateOneWithoutArtistsOnReleasesInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutArtistsOnReleasesInput
  create: ArtistCreateWithoutArtistsOnReleasesInput
  delete: Boolean
  disconnect: Boolean
  update: ArtistUpdateWithoutArtistsOnReleasesInput
  upsert: ArtistUpsertWithoutArtistsOnReleasesInput
}

input ArtistUpdateWithWhereUniqueWithoutReleasesInput {
  data: ArtistUpdateWithoutReleasesInput!
  where: ArtistWhereUniqueInput!
}

input ArtistUpdateWithoutArtistsOnReleasesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  releases: ReleaseUpdateManyWithoutArtistsInput
}

input ArtistUpdateWithoutReleasesInput {
  artistsOnReleases: ArtistsOnReleasesUpdateManyWithoutArtistInput
  createdAt: DateTimeFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ArtistUpsertWithWhereUniqueWithoutReleasesInput {
  create: ArtistCreateWithoutReleasesInput!
  update: ArtistUpdateWithoutReleasesInput!
  where: ArtistWhereUniqueInput!
}

input ArtistUpsertWithoutArtistsOnReleasesInput {
  create: ArtistCreateWithoutArtistsOnReleasesInput!
  update: ArtistUpdateWithoutArtistsOnReleasesInput!
}

input ArtistWhereInput {
  AND: [ArtistWhereInput!]
  NOT: [ArtistWhereInput!]
  OR: [ArtistWhereInput!]
  artistsOnReleases: ArtistsOnReleasesListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  image: StringFilter
  name: StringFilter
  releases: ReleaseListRelationFilter
}

input ArtistWhereUniqueInput {
  id: Int
}

type ArtistsOnReleases {
  artist: Artist
  artistId: Int!
  createdAt: DateTime!
  release: Release
  releaseId: Int!
  role: Role!
}

input ArtistsOnReleasesArtistIdReleaseIdCompoundUniqueInput {
  artistId: Int!
  releaseId: Int!
}

type ArtistsOnReleasesAvgAggregate {
  artistId: Float
  releaseId: Float
}

type ArtistsOnReleasesCountAggregate {
  _all: Int!
  artistId: Int!
  createdAt: Int!
  releaseId: Int!
  role: Int!
}

input ArtistsOnReleasesCreateInput {
  artist: ArtistCreateNestedOneWithoutArtistsOnReleasesInput
  createdAt: DateTime
  release: ReleaseCreateNestedOneWithoutArtistsOnReleasesInput
  role: Role
}

input ArtistsOnReleasesCreateManyArtistInput {
  createdAt: DateTime
  releaseId: Int!
  role: Role
}

input ArtistsOnReleasesCreateManyArtistInputEnvelope {
  data: [ArtistsOnReleasesCreateManyArtistInput!]!
  skipDuplicates: Boolean
}

input ArtistsOnReleasesCreateManyInput {
  artistId: Int!
  createdAt: DateTime
  releaseId: Int!
  role: Role
}

input ArtistsOnReleasesCreateManyReleaseInput {
  artistId: Int!
  createdAt: DateTime
  role: Role
}

input ArtistsOnReleasesCreateManyReleaseInputEnvelope {
  data: [ArtistsOnReleasesCreateManyReleaseInput!]!
  skipDuplicates: Boolean
}

input ArtistsOnReleasesCreateNestedManyWithoutArtistInput {
  connect: [ArtistsOnReleasesWhereUniqueInput!]
  connectOrCreate: [ArtistsOnReleasesCreateOrConnectWithoutArtistInput!]
  create: [ArtistsOnReleasesCreateWithoutArtistInput!]
  createMany: ArtistsOnReleasesCreateManyArtistInputEnvelope
}

input ArtistsOnReleasesCreateNestedManyWithoutReleaseInput {
  connect: [ArtistsOnReleasesWhereUniqueInput!]
  connectOrCreate: [ArtistsOnReleasesCreateOrConnectWithoutReleaseInput!]
  create: [ArtistsOnReleasesCreateWithoutReleaseInput!]
  createMany: ArtistsOnReleasesCreateManyReleaseInputEnvelope
}

input ArtistsOnReleasesCreateOrConnectWithoutArtistInput {
  create: ArtistsOnReleasesCreateWithoutArtistInput!
  where: ArtistsOnReleasesWhereUniqueInput!
}

input ArtistsOnReleasesCreateOrConnectWithoutReleaseInput {
  create: ArtistsOnReleasesCreateWithoutReleaseInput!
  where: ArtistsOnReleasesWhereUniqueInput!
}

input ArtistsOnReleasesCreateWithoutArtistInput {
  createdAt: DateTime
  release: ReleaseCreateNestedOneWithoutArtistsOnReleasesInput
  role: Role
}

input ArtistsOnReleasesCreateWithoutReleaseInput {
  artist: ArtistCreateNestedOneWithoutArtistsOnReleasesInput
  createdAt: DateTime
  role: Role
}

type ArtistsOnReleasesGroupBy {
  _avg: ArtistsOnReleasesAvgAggregate
  _count: ArtistsOnReleasesCountAggregate
  _max: ArtistsOnReleasesMaxAggregate
  _min: ArtistsOnReleasesMinAggregate
  _sum: ArtistsOnReleasesSumAggregate
  artistId: Int!
  createdAt: DateTime!
  releaseId: Int!
  role: Role!
}

input ArtistsOnReleasesListRelationFilter {
  every: ArtistsOnReleasesWhereInput
  none: ArtistsOnReleasesWhereInput
  some: ArtistsOnReleasesWhereInput
}

type ArtistsOnReleasesMaxAggregate {
  artistId: Int
  createdAt: DateTime
  releaseId: Int
  role: Role
}

type ArtistsOnReleasesMinAggregate {
  artistId: Int
  createdAt: DateTime
  releaseId: Int
  role: Role
}

input ArtistsOnReleasesOrderByInput {
  artistId: SortOrder
  createdAt: SortOrder
  releaseId: SortOrder
  role: SortOrder
}

enum ArtistsOnReleasesScalarFieldEnum {
  artistId
  createdAt
  releaseId
  role
}

input ArtistsOnReleasesScalarWhereInput {
  AND: [ArtistsOnReleasesScalarWhereInput!]
  NOT: [ArtistsOnReleasesScalarWhereInput!]
  OR: [ArtistsOnReleasesScalarWhereInput!]
  artistId: IntFilter
  createdAt: DateTimeFilter
  releaseId: IntFilter
  role: EnumRoleFilter
}

input ArtistsOnReleasesScalarWhereWithAggregatesInput {
  AND: [ArtistsOnReleasesScalarWhereWithAggregatesInput!]
  NOT: [ArtistsOnReleasesScalarWhereWithAggregatesInput!]
  OR: [ArtistsOnReleasesScalarWhereWithAggregatesInput!]
  artistId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  releaseId: IntWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
}

type ArtistsOnReleasesSumAggregate {
  artistId: Int
  releaseId: Int
}

input ArtistsOnReleasesUpdateInput {
  artist: ArtistUpdateOneWithoutArtistsOnReleasesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  release: ReleaseUpdateOneWithoutArtistsOnReleasesInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ArtistsOnReleasesUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ArtistsOnReleasesUpdateManyWithWhereWithoutArtistInput {
  data: ArtistsOnReleasesUpdateManyMutationInput!
  where: ArtistsOnReleasesScalarWhereInput!
}

input ArtistsOnReleasesUpdateManyWithWhereWithoutReleaseInput {
  data: ArtistsOnReleasesUpdateManyMutationInput!
  where: ArtistsOnReleasesScalarWhereInput!
}

input ArtistsOnReleasesUpdateManyWithoutArtistInput {
  connect: [ArtistsOnReleasesWhereUniqueInput!]
  connectOrCreate: [ArtistsOnReleasesCreateOrConnectWithoutArtistInput!]
  create: [ArtistsOnReleasesCreateWithoutArtistInput!]
  createMany: ArtistsOnReleasesCreateManyArtistInputEnvelope
  delete: [ArtistsOnReleasesWhereUniqueInput!]
  deleteMany: [ArtistsOnReleasesScalarWhereInput!]
  disconnect: [ArtistsOnReleasesWhereUniqueInput!]
  set: [ArtistsOnReleasesWhereUniqueInput!]
  update: [ArtistsOnReleasesUpdateWithWhereUniqueWithoutArtistInput!]
  updateMany: [ArtistsOnReleasesUpdateManyWithWhereWithoutArtistInput!]
  upsert: [ArtistsOnReleasesUpsertWithWhereUniqueWithoutArtistInput!]
}

input ArtistsOnReleasesUpdateManyWithoutReleaseInput {
  connect: [ArtistsOnReleasesWhereUniqueInput!]
  connectOrCreate: [ArtistsOnReleasesCreateOrConnectWithoutReleaseInput!]
  create: [ArtistsOnReleasesCreateWithoutReleaseInput!]
  createMany: ArtistsOnReleasesCreateManyReleaseInputEnvelope
  delete: [ArtistsOnReleasesWhereUniqueInput!]
  deleteMany: [ArtistsOnReleasesScalarWhereInput!]
  disconnect: [ArtistsOnReleasesWhereUniqueInput!]
  set: [ArtistsOnReleasesWhereUniqueInput!]
  update: [ArtistsOnReleasesUpdateWithWhereUniqueWithoutReleaseInput!]
  updateMany: [ArtistsOnReleasesUpdateManyWithWhereWithoutReleaseInput!]
  upsert: [ArtistsOnReleasesUpsertWithWhereUniqueWithoutReleaseInput!]
}

input ArtistsOnReleasesUpdateWithWhereUniqueWithoutArtistInput {
  data: ArtistsOnReleasesUpdateWithoutArtistInput!
  where: ArtistsOnReleasesWhereUniqueInput!
}

input ArtistsOnReleasesUpdateWithWhereUniqueWithoutReleaseInput {
  data: ArtistsOnReleasesUpdateWithoutReleaseInput!
  where: ArtistsOnReleasesWhereUniqueInput!
}

input ArtistsOnReleasesUpdateWithoutArtistInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  release: ReleaseUpdateOneWithoutArtistsOnReleasesInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ArtistsOnReleasesUpdateWithoutReleaseInput {
  artist: ArtistUpdateOneWithoutArtistsOnReleasesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ArtistsOnReleasesUpsertWithWhereUniqueWithoutArtistInput {
  create: ArtistsOnReleasesCreateWithoutArtistInput!
  update: ArtistsOnReleasesUpdateWithoutArtistInput!
  where: ArtistsOnReleasesWhereUniqueInput!
}

input ArtistsOnReleasesUpsertWithWhereUniqueWithoutReleaseInput {
  create: ArtistsOnReleasesCreateWithoutReleaseInput!
  update: ArtistsOnReleasesUpdateWithoutReleaseInput!
  where: ArtistsOnReleasesWhereUniqueInput!
}

input ArtistsOnReleasesWhereInput {
  AND: [ArtistsOnReleasesWhereInput!]
  NOT: [ArtistsOnReleasesWhereInput!]
  OR: [ArtistsOnReleasesWhereInput!]
  artist: ArtistRelationFilter
  artistId: IntFilter
  createdAt: DateTimeFilter
  release: ReleaseRelationFilter
  releaseId: IntFilter
  role: EnumRoleFilter
}

input ArtistsOnReleasesWhereUniqueInput {
  artistId_releaseId: ArtistsOnReleasesArtistIdReleaseIdCompoundUniqueInput
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumReleaseTypeFieldUpdateOperationsInput {
  set: ReleaseType
}

input EnumReleaseTypeFilter {
  equals: ReleaseType
  in: [ReleaseType!]
  not: NestedEnumReleaseTypeFilter
  notIn: [ReleaseType!]
}

input EnumReleaseTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumReleaseTypeFilter
  _min: NestedEnumReleaseTypeFilter
  equals: ReleaseType
  in: [ReleaseType!]
  not: NestedEnumReleaseTypeWithAggregatesFilter
  notIn: [ReleaseType!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type LFMArtist {
  bio: LFMBio!
  name: String!
  url: String!
}

type LFMArtistReturn {
  artist: LFMArtist!
}

type LFMBio {
  content: String!
  summary: String!
}

type Mutation {
  createArtist(data: ArtistCreateInput!): Artist!
  createArtistsOnReleases(data: ArtistsOnReleasesCreateInput!): ArtistsOnReleases!
  createManyArtist(data: [ArtistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyArtistsOnReleases(data: [ArtistsOnReleasesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRelease(data: [ReleaseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createRelease(data: ReleaseCreateInput!): Release!
  deleteArtist(where: ArtistWhereUniqueInput!): Artist
  deleteArtistsOnReleases(where: ArtistsOnReleasesWhereUniqueInput!): ArtistsOnReleases
  deleteManyArtist(where: ArtistWhereInput): AffectedRowsOutput!
  deleteManyArtistsOnReleases(where: ArtistsOnReleasesWhereInput): AffectedRowsOutput!
  deleteManyRelease(where: ReleaseWhereInput): AffectedRowsOutput!
  deleteRelease(where: ReleaseWhereUniqueInput!): Release
  updateArtist(data: ArtistUpdateInput!, where: ArtistWhereUniqueInput!): Artist
  updateArtistsOnReleases(data: ArtistsOnReleasesUpdateInput!, where: ArtistsOnReleasesWhereUniqueInput!): ArtistsOnReleases
  updateManyArtist(data: ArtistUpdateManyMutationInput!, where: ArtistWhereInput): AffectedRowsOutput!
  updateManyArtistsOnReleases(data: ArtistsOnReleasesUpdateManyMutationInput!, where: ArtistsOnReleasesWhereInput): AffectedRowsOutput!
  updateManyRelease(data: ReleaseUpdateManyMutationInput!, where: ReleaseWhereInput): AffectedRowsOutput!
  updateRelease(data: ReleaseUpdateInput!, where: ReleaseWhereUniqueInput!): Release
  upsertArtist(create: ArtistCreateInput!, update: ArtistUpdateInput!, where: ArtistWhereUniqueInput!): Artist!
  upsertArtistsOnReleases(create: ArtistsOnReleasesCreateInput!, update: ArtistsOnReleasesUpdateInput!, where: ArtistsOnReleasesWhereUniqueInput!): ArtistsOnReleases!
  upsertRelease(create: ReleaseCreateInput!, update: ReleaseUpdateInput!, where: ReleaseWhereUniqueInput!): Release!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumReleaseTypeFilter {
  equals: ReleaseType
  in: [ReleaseType!]
  not: NestedEnumReleaseTypeFilter
  notIn: [ReleaseType!]
}

input NestedEnumReleaseTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumReleaseTypeFilter
  _min: NestedEnumReleaseTypeFilter
  equals: ReleaseType
  in: [ReleaseType!]
  not: NestedEnumReleaseTypeWithAggregatesFilter
  notIn: [ReleaseType!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  aggregateArtist(cursor: ArtistWhereUniqueInput, orderBy: [ArtistOrderByInput!], skip: Int, take: Int, where: ArtistWhereInput): AggregateArtist!
  aggregateArtistsOnReleases(cursor: ArtistsOnReleasesWhereUniqueInput, orderBy: [ArtistsOnReleasesOrderByInput!], skip: Int, take: Int, where: ArtistsOnReleasesWhereInput): AggregateArtistsOnReleases!
  aggregateRelease(cursor: ReleaseWhereUniqueInput, orderBy: [ReleaseOrderByInput!], skip: Int, take: Int, where: ReleaseWhereInput): AggregateRelease!
  artist(where: ArtistWhereUniqueInput!): Artist
  artists(cursor: ArtistWhereUniqueInput, distinct: [ArtistScalarFieldEnum!], orderBy: [ArtistOrderByInput!], skip: Int, take: Int, where: ArtistWhereInput): [Artist!]!
  findFirstArtist(cursor: ArtistWhereUniqueInput, distinct: [ArtistScalarFieldEnum!], orderBy: [ArtistOrderByInput!], skip: Int, take: Int, where: ArtistWhereInput): Artist
  findFirstArtistsOnReleases(cursor: ArtistsOnReleasesWhereUniqueInput, distinct: [ArtistsOnReleasesScalarFieldEnum!], orderBy: [ArtistsOnReleasesOrderByInput!], skip: Int, take: Int, where: ArtistsOnReleasesWhereInput): ArtistsOnReleases
  findFirstRelease(cursor: ReleaseWhereUniqueInput, distinct: [ReleaseScalarFieldEnum!], orderBy: [ReleaseOrderByInput!], skip: Int, take: Int, where: ReleaseWhereInput): Release
  findManyArtistsOnReleases(cursor: ArtistsOnReleasesWhereUniqueInput, distinct: [ArtistsOnReleasesScalarFieldEnum!], orderBy: [ArtistsOnReleasesOrderByInput!], skip: Int, take: Int, where: ArtistsOnReleasesWhereInput): [ArtistsOnReleases!]!
  findUniqueArtistsOnReleases(where: ArtistsOnReleasesWhereUniqueInput!): ArtistsOnReleases
  groupByArtist(by: [ArtistScalarFieldEnum!]!, having: ArtistScalarWhereWithAggregatesInput, orderBy: [ArtistOrderByInput!], skip: Int, take: Int, where: ArtistWhereInput): [ArtistGroupBy!]!
  groupByArtistsOnReleases(by: [ArtistsOnReleasesScalarFieldEnum!]!, having: ArtistsOnReleasesScalarWhereWithAggregatesInput, orderBy: [ArtistsOnReleasesOrderByInput!], skip: Int, take: Int, where: ArtistsOnReleasesWhereInput): [ArtistsOnReleasesGroupBy!]!
  groupByRelease(by: [ReleaseScalarFieldEnum!]!, having: ReleaseScalarWhereWithAggregatesInput, orderBy: [ReleaseOrderByInput!], skip: Int, take: Int, where: ReleaseWhereInput): [ReleaseGroupBy!]!
  lastFMArtist(artist: String!): LFMArtistReturn!
  release(where: ReleaseWhereUniqueInput!): Release
  releases(cursor: ReleaseWhereUniqueInput, distinct: [ReleaseScalarFieldEnum!], orderBy: [ReleaseOrderByInput!], skip: Int, take: Int, where: ReleaseWhereInput): [Release!]!
}

enum QueryMode {
  default
  insensitive
}

type Release {
  artists(cursor: ArtistWhereUniqueInput, distinct: [ArtistScalarFieldEnum!], orderBy: [ArtistOrderByInput!], skip: Int, take: Int, where: ArtistWhereInput): [Artist!]!
  artistsOnReleases(cursor: ArtistsOnReleasesWhereUniqueInput, distinct: [ArtistsOnReleasesScalarFieldEnum!], orderBy: [ArtistsOnReleasesOrderByInput!], skip: Int, take: Int, where: ArtistsOnReleasesWhereInput): [ArtistsOnReleases!]!
  createdAt: DateTime!
  id: Int!
  image: String!
  name: String!
  releaseDate: DateTime!
  tags(cursor: TagWhereUniqueInput, distinct: [TagScalarFieldEnum!], orderBy: [TagOrderByInput!], skip: Int, take: Int, where: TagWhereInput): [Tag!]!
  type: ReleaseType!
  url: String!
}

type ReleaseAvgAggregate {
  id: Float
}

type ReleaseCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  image: Int!
  name: Int!
  releaseDate: Int!
  type: Int!
  url: Int!
}

input ReleaseCreateInput {
  artists: ArtistCreateNestedManyWithoutReleasesInput
  artistsOnReleases: ArtistsOnReleasesCreateNestedManyWithoutReleaseInput
  createdAt: DateTime
  image: String
  name: String!
  releaseDate: DateTime!
  tags: TagCreateNestedManyWithoutReleasesInput
  type: ReleaseType
  url: String!
}

input ReleaseCreateManyInput {
  createdAt: DateTime
  id: Int
  image: String
  name: String!
  releaseDate: DateTime!
  type: ReleaseType
  url: String!
}

input ReleaseCreateNestedManyWithoutArtistsInput {
  connect: [ReleaseWhereUniqueInput!]
  connectOrCreate: [ReleaseCreateOrConnectWithoutArtistsInput!]
  create: [ReleaseCreateWithoutArtistsInput!]
}

input ReleaseCreateNestedOneWithoutArtistsOnReleasesInput {
  connect: ReleaseWhereUniqueInput
  connectOrCreate: ReleaseCreateOrConnectWithoutArtistsOnReleasesInput
  create: ReleaseCreateWithoutArtistsOnReleasesInput
}

input ReleaseCreateOrConnectWithoutArtistsInput {
  create: ReleaseCreateWithoutArtistsInput!
  where: ReleaseWhereUniqueInput!
}

input ReleaseCreateOrConnectWithoutArtistsOnReleasesInput {
  create: ReleaseCreateWithoutArtistsOnReleasesInput!
  where: ReleaseWhereUniqueInput!
}

input ReleaseCreateWithoutArtistsInput {
  artistsOnReleases: ArtistsOnReleasesCreateNestedManyWithoutReleaseInput
  createdAt: DateTime
  image: String
  name: String!
  releaseDate: DateTime!
  tags: TagCreateNestedManyWithoutReleasesInput
  type: ReleaseType
  url: String!
}

input ReleaseCreateWithoutArtistsOnReleasesInput {
  artists: ArtistCreateNestedManyWithoutReleasesInput
  createdAt: DateTime
  image: String
  name: String!
  releaseDate: DateTime!
  tags: TagCreateNestedManyWithoutReleasesInput
  type: ReleaseType
  url: String!
}

type ReleaseGroupBy {
  _avg: ReleaseAvgAggregate
  _count: ReleaseCountAggregate
  _max: ReleaseMaxAggregate
  _min: ReleaseMinAggregate
  _sum: ReleaseSumAggregate
  createdAt: DateTime!
  id: Int!
  image: String!
  name: String!
  releaseDate: DateTime!
  type: ReleaseType!
  url: String!
}

input ReleaseListRelationFilter {
  every: ReleaseWhereInput
  none: ReleaseWhereInput
  some: ReleaseWhereInput
}

type ReleaseMaxAggregate {
  createdAt: DateTime
  id: Int
  image: String
  name: String
  releaseDate: DateTime
  type: ReleaseType
  url: String
}

type ReleaseMinAggregate {
  createdAt: DateTime
  id: Int
  image: String
  name: String
  releaseDate: DateTime
  type: ReleaseType
  url: String
}

input ReleaseOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  releaseDate: SortOrder
  type: SortOrder
  url: SortOrder
}

input ReleaseRelationFilter {
  is: ReleaseWhereInput
  isNot: ReleaseWhereInput
}

enum ReleaseScalarFieldEnum {
  createdAt
  id
  image
  name
  releaseDate
  type
  url
}

input ReleaseScalarWhereInput {
  AND: [ReleaseScalarWhereInput!]
  NOT: [ReleaseScalarWhereInput!]
  OR: [ReleaseScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  image: StringFilter
  name: StringFilter
  releaseDate: DateTimeFilter
  type: EnumReleaseTypeFilter
  url: StringFilter
}

input ReleaseScalarWhereWithAggregatesInput {
  AND: [ReleaseScalarWhereWithAggregatesInput!]
  NOT: [ReleaseScalarWhereWithAggregatesInput!]
  OR: [ReleaseScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  image: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  releaseDate: DateTimeWithAggregatesFilter
  type: EnumReleaseTypeWithAggregatesFilter
  url: StringWithAggregatesFilter
}

type ReleaseSumAggregate {
  id: Int
}

enum ReleaseType {
  ALBUM
  ANTHOLOGY
  COMPILATION
  CONCERT
  DJMIX
  EP
  INTERVIEW
  LIVEALBUM
  MINIALBUM
  MIXTAPE
  PROMO
  SINGLE
  SOUNDTRACK
  UNKNOWN
  UNOFFICIAL
}

input ReleaseUpdateInput {
  artists: ArtistUpdateManyWithoutReleasesInput
  artistsOnReleases: ArtistsOnReleasesUpdateManyWithoutReleaseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutReleasesInput
  type: EnumReleaseTypeFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input ReleaseUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  type: EnumReleaseTypeFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input ReleaseUpdateManyWithWhereWithoutArtistsInput {
  data: ReleaseUpdateManyMutationInput!
  where: ReleaseScalarWhereInput!
}

input ReleaseUpdateManyWithoutArtistsInput {
  connect: [ReleaseWhereUniqueInput!]
  connectOrCreate: [ReleaseCreateOrConnectWithoutArtistsInput!]
  create: [ReleaseCreateWithoutArtistsInput!]
  delete: [ReleaseWhereUniqueInput!]
  deleteMany: [ReleaseScalarWhereInput!]
  disconnect: [ReleaseWhereUniqueInput!]
  set: [ReleaseWhereUniqueInput!]
  update: [ReleaseUpdateWithWhereUniqueWithoutArtistsInput!]
  updateMany: [ReleaseUpdateManyWithWhereWithoutArtistsInput!]
  upsert: [ReleaseUpsertWithWhereUniqueWithoutArtistsInput!]
}

input ReleaseUpdateOneWithoutArtistsOnReleasesInput {
  connect: ReleaseWhereUniqueInput
  connectOrCreate: ReleaseCreateOrConnectWithoutArtistsOnReleasesInput
  create: ReleaseCreateWithoutArtistsOnReleasesInput
  delete: Boolean
  disconnect: Boolean
  update: ReleaseUpdateWithoutArtistsOnReleasesInput
  upsert: ReleaseUpsertWithoutArtistsOnReleasesInput
}

input ReleaseUpdateWithWhereUniqueWithoutArtistsInput {
  data: ReleaseUpdateWithoutArtistsInput!
  where: ReleaseWhereUniqueInput!
}

input ReleaseUpdateWithoutArtistsInput {
  artistsOnReleases: ArtistsOnReleasesUpdateManyWithoutReleaseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutReleasesInput
  type: EnumReleaseTypeFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input ReleaseUpdateWithoutArtistsOnReleasesInput {
  artists: ArtistUpdateManyWithoutReleasesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  tags: TagUpdateManyWithoutReleasesInput
  type: EnumReleaseTypeFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input ReleaseUpsertWithWhereUniqueWithoutArtistsInput {
  create: ReleaseCreateWithoutArtistsInput!
  update: ReleaseUpdateWithoutArtistsInput!
  where: ReleaseWhereUniqueInput!
}

input ReleaseUpsertWithoutArtistsOnReleasesInput {
  create: ReleaseCreateWithoutArtistsOnReleasesInput!
  update: ReleaseUpdateWithoutArtistsOnReleasesInput!
}

input ReleaseWhereInput {
  AND: [ReleaseWhereInput!]
  NOT: [ReleaseWhereInput!]
  OR: [ReleaseWhereInput!]
  artists: ArtistListRelationFilter
  artistsOnReleases: ArtistsOnReleasesListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  image: StringFilter
  name: StringFilter
  releaseDate: DateTimeFilter
  tags: TagListRelationFilter
  type: EnumReleaseTypeFilter
  url: StringFilter
}

input ReleaseWhereUniqueInput {
  id: Int
  url: String
}

enum Role {
  COMPOSER
  CONDUCTOR
  DJ
  GUEST
  MAIN
  PRODUCER
  REMIXER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Tag {
  id: Int!
  name: String!
}

input TagCreateNestedManyWithoutReleasesInput {
  connect: [TagWhereUniqueInput!]
  connectOrCreate: [TagCreateOrConnectWithoutReleasesInput!]
  create: [TagCreateWithoutReleasesInput!]
}

input TagCreateOrConnectWithoutReleasesInput {
  create: TagCreateWithoutReleasesInput!
  where: TagWhereUniqueInput!
}

input TagCreateWithoutReleasesInput {
  name: String!
}

input TagListRelationFilter {
  every: TagWhereInput
  none: TagWhereInput
  some: TagWhereInput
}

input TagOrderByInput {
  id: SortOrder
  name: SortOrder
}

enum TagScalarFieldEnum {
  id
  name
}

input TagScalarWhereInput {
  AND: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  id: IntFilter
  name: StringFilter
}

input TagUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input TagUpdateManyWithWhereWithoutReleasesInput {
  data: TagUpdateManyMutationInput!
  where: TagScalarWhereInput!
}

input TagUpdateManyWithoutReleasesInput {
  connect: [TagWhereUniqueInput!]
  connectOrCreate: [TagCreateOrConnectWithoutReleasesInput!]
  create: [TagCreateWithoutReleasesInput!]
  delete: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  disconnect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  update: [TagUpdateWithWhereUniqueWithoutReleasesInput!]
  updateMany: [TagUpdateManyWithWhereWithoutReleasesInput!]
  upsert: [TagUpsertWithWhereUniqueWithoutReleasesInput!]
}

input TagUpdateWithWhereUniqueWithoutReleasesInput {
  data: TagUpdateWithoutReleasesInput!
  where: TagWhereUniqueInput!
}

input TagUpdateWithoutReleasesInput {
  name: StringFieldUpdateOperationsInput
}

input TagUpsertWithWhereUniqueWithoutReleasesInput {
  create: TagCreateWithoutReleasesInput!
  update: TagUpdateWithoutReleasesInput!
  where: TagWhereUniqueInput!
}

input TagWhereInput {
  AND: [TagWhereInput!]
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  id: IntFilter
  name: StringFilter
  releases: ReleaseListRelationFilter
}

input TagWhereUniqueInput {
  id: Int
}
